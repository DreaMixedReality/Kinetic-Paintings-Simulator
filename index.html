<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Matrice 3D + Télécommande (fix rotations & centrage, panneau bas)</title>
<style>
  /* =========================================================
     VARIABLES CSS GLOBALES
     ========================================================= */
  :root{
    --n: 2;                 /* taille matrice n x n */
    --F: 2;                 /* nb d'étages max (0..F) */
    --square-size: 100px;    /* taille d’un tableau */
    --gap: 0px;            /* espacement X = Y entre tableaux (UNIQUE) */
    --floor-depth: 10px;    /* profondeur par étage (Z) */
  }

  *{ box-sizing: border-box; }
  body{
    margin:0; height:100vh; background:#0f111a; color:#e9eef7;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    overflow:hidden;
  }

  /* =========================================================
     VIEWER 3D (plein écran)
     - viewWrap : rotation VISUELLE X/Y (drag souris) — pas de changement logique
     - logicWrap: rotation LOGIQUE Z (bouton Rotation)
     ========================================================= */
  #viewer{
    position: absolute; inset:0 0 90px 0;  /* réserve 90px pour le panneau bas */
    display:flex; align-items:center; justify-content:center;
    perspective: 1100px;
    background: radial-gradient(1200px 600px at center, #1b2133, #121826);
    user-select:none;
  }
  #viewWrap{ transform-style: preserve-3d; }
  #logicWrap{ transform-style: preserve-3d; transform-origin:center center; }

  /* =========================================================
     GRILLE DES TABLEAUX
     ========================================================= */
  #grid{
    display:grid;
    transform-style: preserve-3d;
    gap: var(--gap); /* ⇐ ESPACEMENT IDENTIQUE X ET Y, contrôlé par slider Gap */
    grid-template-columns: repeat(var(--n), var(--square-size));
    grid-template-rows:    repeat(var(--n), var(--square-size));
  }
  .cell{
    width: var(--square-size); height: var(--square-size);
    position: relative; transform-style: preserve-3d;
  }
  .tile{
    position:absolute; left:50%; top:50%;
    width: var(--square-size); height: var(--square-size);
    border-radius: 10px; border:2px solid #0c4a6e;
    background: linear-gradient(#b9e6ff,#79c5ff);
    color:#05324a; font-weight:800; display:flex; align-items:center; justify-content:center;
    box-shadow: 0 8px 20px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.25);
    transform-origin: 50% 50%;
    /* IMPORTANT : translation centrée + profondeur + rotation */
    transform: translate(-50%, -50%) translateZ(0px) rotateZ(0deg);
    transition: transform 480ms cubic-bezier(.3,.7,.2,1);
    will-change: transform;
  }

  /* =========================================================
     PANNEAU DE CONTRÔLE (EN BAS)
     ========================================================= */
  #controlPanel{
    position: absolute; left:0; right:0; bottom:0; height:90px;
    background:#0c111b; border-top:1px solid #1f2937;
    display:flex; align-items:center; justify-content:center; gap:18px; padding:8px 12px;
  }
  .btn{
    padding:10px 14px; border-radius:10px; border:2px solid #0f172a;
    background:#e5e7eb; color:#0f172a; font-weight:800; cursor:pointer;
  }
  .btn:disabled{ opacity:.6; cursor:not-allowed; }
  .sliders{ display:flex; align-items:center; gap:18px; }
  .sliders label{ display:flex; flex-direction:column; align-items:flex-start; font-size:12px; }
  .sliders input[type="range"]{ width:220px; }

  #remote{
    display:grid; justify-content:center; gap:8px;
    grid-template-columns: repeat(var(--n), 44px);
    grid-template-rows:    repeat(var(--n), 44px);
  }
  #remote button{
    width:44px; height:44px; border-radius:10px; border:2px solid #0b5a20;
    background: linear-gradient(#a7efb3,#73d88a); font-weight:800; color:#0b3816; cursor:pointer;
    box-shadow: 0 6px 12px rgba(0,0,0,.28), inset 0 0 0 1px rgba(255,255,255,.25);
  }
  #remote button:disabled{ opacity:.6; cursor:not-allowed; }
</style>
</head>
<body>

<!-- ===================== VIEWER 3D ===================== -->
<div id="viewer">
  <div id="viewWrap">
    <div id="logicWrap">
      <div id="grid"></div>
    </div>
  </div>
</div>

<!-- ===================== PANNEAU BAS ===================== -->
<div id="controlPanel">
  <div id="remote"></div>

  <div class="sliders">
    <label>n
      <input type="range" id="nSlider" min="1" max="8" value="2"/>
    </label>
    <label>F (étages)
      <input type="range" id="fSlider" min="1" max="8" value="2"/>
    </label>
    <label>Gap (espacement XY)
      <input type="range" id="gapSlider" min="0" max="120" value="0"/>
    </label>
  </div>

  <button id="rotateBtn" class="btn" title="Clic court: +45° | Appui long: -45°">Rotation globale (Z)</button>
  <button id="resetViewBtn" class="btn">Reset Vue 3D</button>
</div>

<script>
/* =========================================================
   ETAT GLOBAL (NE TOUCHE PAS AUX PARTIES QUI FONCTIONNENT)
   ========================================================= */
const state = {
  n: 2,
  F: 2,
  gap: 0,
  floorDepth: 10,

  // ROTATIONS — IMPORTANT : garder des angles "bruts" pour éviter les 4 tours
  logicalRotationRaw: 0,    // degrés cumulés (peut être négatif). Utilisé pour l'anim.
  rotateStep: 45,           // pas de rotation globale

  isAnimating: false,       // verrou global pendant toute anim (désactive les boutons)
  tiles: [],                // [{row,col,floor,rotRaw,el}]
};

/* =========================================================
   HELPERS
   ========================================================= */
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const mod = (a,n)=>((a % n)+n)%n;

function onTransitionEndOnce(el, prop, timeout=1200){
  return new Promise(resolve=>{
    let done=false;
    const t = setTimeout(()=>{ if(!done){done=true; cleanup(); resolve();}}, timeout);
    const handler = (e)=>{ if(done) return; if(e.propertyName===prop){ done=true; cleanup(); resolve(); } };
    function cleanup(){ clearTimeout(t); el.removeEventListener('transitionend', handler); }
    el.addEventListener('transitionend', handler);
  });
}

/* =========================================================
   CONSTRUCTION GRILLE + TELECOMMANDE
   ========================================================= */
const grid = document.getElementById('grid');
const remote = document.getElementById('remote');

function buildGrid(){
  document.documentElement.style.setProperty('--n', state.n);
  document.documentElement.style.setProperty('--gap', `${state.gap}px`);

  grid.innerHTML = '';
  grid.style.gridTemplateColumns = `repeat(${state.n}, var(--square-size))`;
  grid.style.gridTemplateRows    = `repeat(${state.n}, var(--square-size))`;

  state.tiles = [];
  for(let r=0;r<state.n;r++){
    for(let c=0;c<state.n;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.row = r;
      cell.dataset.col = c;

      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.textContent = `${r},${c}`;
      cell.appendChild(tile);
      grid.appendChild(cell);

      state.tiles.push({row:r, col:c, floor:0, rotRaw:0, el:tile});
      applyTileTransform(state.tiles[state.tiles.length-1]);
    }
  }
}

function buildRemote(){
  remote.innerHTML = '';
  remote.style.gridTemplateColumns = `repeat(${state.n}, 44px)`;
  remote.style.gridTemplateRows    = `repeat(${state.n}, 44px)`;

  for(let vr=0; vr<state.n; vr++){
    for(let vc=0; vc<state.n; vc++){
      const btn = document.createElement('button');
      btn.dataset.visualRow = vr;
      btn.dataset.visualCol = vc;
      btn.dataset.targetRow = vr;  // mapping initial = identité
      btn.dataset.targetCol = vc;
      btn.textContent = `→ ${vr},${vc}`;

      attachPressHandlers(
        btn,
        () => triggerTileSequence(parseInt(btn.dataset.targetRow,10), parseInt(btn.dataset.targetCol,10), false), // court
        () => triggerTileSequence(parseInt(btn.dataset.targetRow,10), parseInt(btn.dataset.targetCol,10), true)   // long (sens inverse)
      );

      remote.appendChild(btn);
    }
  }
  updateMapping(); // initial
}

/* =========================================================
   MAPPING TELECOMMANDE → TABLEAUX
   - Multiple de 90° : recalcul (bouton HG → visuel HG)
   - 45/135/... : mapping inchangé (ancré)
   ========================================================= */
function updateMapping(){
  const angle = mod(state.logicalRotationRaw, 360);
  if (angle % 90 !== 0) return;

  const n = state.n;
  document.querySelectorAll('#remote button').forEach(btn=>{
    const vr = parseInt(btn.dataset.visualRow,10);
    const vc = parseInt(btn.dataset.visualCol,10);

    let r0 = vr, c0 = vc;
    if(angle === 90){
      r0 = n - 1 - vc;
      c0 = vr;
    } else if(angle === 180){
      r0 = n - 1 - vr;
      c0 = n - 1 - vc;
    } else if(angle === 270){
      r0 = vc;
      c0 = n - 1 - vr;
    }
    btn.dataset.targetRow = r0;
    btn.dataset.targetCol = c0;
    btn.textContent = `→ ${r0},${c0}`;
  });
}

/* =========================================================
   TRANSFORMS CENTRÉS (Z normal au plan)
   ========================================================= */
function applyTileTransform(t){
  t.el.style.transform =
    `translate(-50%, -50%) translateZ(${t.floor * state.floorDepth}px) rotateZ(${t.rotRaw}deg)`;
}

/* =========================================================
   APPUI COURT / LONG (long déclenche IMMÉDIATEMENT)
   ========================================================= */
function attachPressHandlers(el, onShort, onLong, threshold=400){
  let timer=null, longFired=false, down=false, pid=null;

  const clear = ()=>{
    if(timer){ clearTimeout(timer); timer=null; }
    longFired=false; down=false;
    try{ if(pid!==null) el.releasePointerCapture(pid); }catch{}
    pid=null;
  };

  el.addEventListener('pointerdown', e=>{
    if(state.isAnimating) return;
    down=true; longFired=false; pid=e.pointerId;
    try{ el.setPointerCapture(e.pointerId); }catch{}
    timer = setTimeout(()=>{
      if(!down) return;
      longFired=true;
      onLong();                    // déclenche IMMÉDIATEMENT
    }, threshold);
  });

  el.addEventListener('pointerup', ()=>{
    if(!down) return;
    const wasLong = longFired;
    clear();
    if(state.isAnimating) return;  // si une anim a démarré entre-temps
    if(!wasLong){ onShort(); }     // court = au relâchement
  });

  el.addEventListener('pointercancel', clear);
  el.addEventListener('pointerleave', ()=>{
    if(!longFired) clear();
  });
}

/* =========================================================
   SEQUENCE D'ANIM PAR TABLEAU (home -> étage 2 -> rotate ±90 -> home)
   - ROTATION **ACCUMULÉE** en utilisant un angle brut (rotRaw)
   - BOUTONS DÉSACTIVÉS pendant l'animation
   ========================================================= */
function getTile(r,c){ return state.tiles.find(t=>t.row===r && t.col===c); }

async function triggerTileSequence(r, c, reverse=false){
  if(state.isAnimating) return;
  state.isAnimating = true;
  setControlsEnabled(false);

  const t = getTile(r,c);
  const targetFloor = clamp(2, 0, state.F);

  try{
    await translateTile(t, targetFloor, 480);
    await rotateTile(t, reverse ? -90 : 90, 480);
    await translateTile(t, 0, 480);
  } finally {
    setControlsEnabled(true);
    state.isAnimating = false;
  }
}

function translateTile(t, floor, duration=480, easing='cubic-bezier(.3,.7,.2,1)'){
  return new Promise(resolve=>{
    t.floor = clamp(floor, 0, state.F);
    t.el.style.transition = `transform ${duration}ms ${easing}`;
    applyTileTransform(t);
    onTransitionEndOnce(t.el, 'transform', duration+200).then(resolve);
  });
}

function rotateTile(t, deltaDeg, duration=480, easing='cubic-bezier(.3,.7,.2,1)'){
  return new Promise(resolve=>{
    // IMPORTANT : angle brut (peut être négatif) pour éviter les 4 tours au premier sens inverse
    const snapped = Math.round(deltaDeg/90)*90;
    t.rotRaw += snapped;                 // ⇐ pas de modulo ici
    t.el.style.transition = `transform ${duration}ms ${easing}`;
    applyTileTransform(t);
    onTransitionEndOnce(t.el, 'transform', duration+200).then(resolve);
  });
}

/* =========================================================
   ROTATION LOGIQUE GLOBALE (Z) — appui court/long
   - Utilise logicalRotationRaw (angle brut), pas de reset
   - Recalcule le mapping si angle % 90 === 0
   - Désactive les boutons pendant l'animation
   ========================================================= */
const logicWrap = document.getElementById('logicWrap');
attachPressHandlers(
  document.getElementById('rotateBtn'),
  () => rotateGlobal(+state.rotateStep, 900),
  () => rotateGlobal(-state.rotateStep, 900)
);

function rotateGlobal(stepDeg, duration=900, easing='cubic-bezier(.3,.7,.2,1)'){
  if(state.isAnimating) return;
  state.isAnimating = true;
  setControlsEnabled(false);

  state.logicalRotationRaw += stepDeg;   // ⇐ angle brut (peut être négatif)
  logicWrap.style.transition = `transform ${duration}ms ${easing}`;
  logicWrap.style.transform  = `rotateZ(${state.logicalRotationRaw}deg)`;

  onTransitionEndOnce(logicWrap, 'transform', duration+200).then(()=>{
    logicWrap.style.transition = '';
    if (mod(state.logicalRotationRaw, 90) === 0) updateMapping();
    setControlsEnabled(true);
    state.isAnimating = false;
  });
}

/* =========================================================
   ROTATION DE VUE (X/Y) — PUR VISUEL (vue initiale parallèle à l'écran)
   ========================================================= */
(function setupViewDrag(){
  const viewer = document.getElementById('viewer');
  const viewWrap = document.getElementById('viewWrap');
  let dragging=false, lastX=0, lastY=0, rx=0, ry=0; // ⇐ vue de face par défaut

  const apply = ()=>{ viewWrap.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg)`; };
  apply();

  viewer.addEventListener('pointerdown', e=>{
    dragging=true; lastX=e.clientX; lastY=e.clientY; viewer.setPointerCapture(e.pointerId);
  });
  viewer.addEventListener('pointerup', e=>{
    dragging=false; viewer.releasePointerCapture(e.pointerId);
  });
  viewer.addEventListener('pointercancel', ()=> dragging=false);
  viewer.addEventListener('pointermove', e=>{
    if(!dragging) return;
    ry += (e.clientX - lastX) * 0.35;
    rx -= (e.clientY - lastY) * 0.35;
    rx = clamp(rx, -80, 80);
    apply();
    lastX=e.clientX; lastY=e.clientY;
  });

  // Reset Vue 3D (ne touche pas à la rotation logique)
  document.getElementById('resetViewBtn').addEventListener('click', ()=>{
    rx = 0; ry = 0; apply();
  });
})();

/* =========================================================
   SLIDERS : N, F, GAP  (ne change que ce qui est demandé)
   ========================================================= */
document.getElementById('nSlider').addEventListener('input', e=>{
  state.n = parseInt(e.target.value,10);
  document.documentElement.style.setProperty('--n', state.n);
  buildGrid();
  buildRemote();
  updateMapping();
});
document.getElementById('fSlider').addEventListener('input', e=>{
  state.F = parseInt(e.target.value,10);
  document.documentElement.style.setProperty('--F', state.F);
});
document.getElementById('gapSlider').addEventListener('input', e=>{
  state.gap = parseInt(e.target.value,10);
  document.documentElement.style.setProperty('--gap', `${state.gap}px`); // ⇐ même valeur X et Y
});

/* =========================================================
   ENABLE/DISABLE DES CONTROLES (réactivé)
   ========================================================= */
function setControlsEnabled(enabled){
  document.querySelectorAll('#remote button, #rotateBtn').forEach(b=> b.disabled = !enabled);
}

/* =========================================================
   INIT
   ========================================================= */
(function init(){
  document.documentElement.style.setProperty('--n', state.n);
  document.documentElement.style.setProperty('--F', state.F);
  document.documentElement.style.setProperty('--gap', `${state.gap}px`);
  buildGrid();
  buildRemote();
  updateMapping(); // état initial
})();
</script>
</body>
</html>
