<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Matrice 3D + Télécommande (donut + tailles dynamiques)</title>
<style>
  :root{
    --n: 2;
    --F: 2;
    --square-size: 100px;   /* sera recalculé dynamiquement */
    --gap: 0px;
    --floor-depth: 30px;

    --remote-btn: 44px;     /* taille d’un bouton télécommande */
  }

  *{ box-sizing: border-box; }
  body{
    margin:0;
    height:100vh;
    background:#fff;
    color:#000;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    display: flex;
    flex-direction: column;
  }

  /* Layout responsive : panneau gauche sur desktop, bas sur mobile */
  @media (min-width: 768px) {
    body {
      flex-direction: row;
    }
    #controlPanel {
      flex-direction: column;
      height: 100%;
      width: 280px;                    /* un peu plus large pour laisser respirer */
      border-right: 1px solid #ccc;
      border-top: none;
      align-items: stretch;
    }
    #viewer {
      flex: 1;
    }
    #remoteWrapper{
      max-height: calc(100vh - 220px); /* laisse la place aux sliders/boutons */
    }
  }

  @media (max-width: 767px) {
    #controlPanel {
      flex-direction: column;
      width: 100%;
      border-top: 1px solid #ccc;
    }
    #viewer {
      flex: 1;
    }
    #remoteWrapper{
      max-width: 100%;
      max-height: 45vh;                /* évite la coupure en hauteur */
    }
  }

  /* ===== Viewer 3D ===== */
  #viewer{
    display:flex;
    align-items:center;
    justify-content:center;
    perspective: 1100px;
    background: #fff;
    user-select:none;
    overflow: hidden;
  }
  #viewWrap{ transform-style: preserve-3d; }
  #logicWrap{ transform-style: preserve-3d; transform-origin:center center; }

  #grid{
    display:grid;
    transform-style: preserve-3d;
    gap: var(--gap);
    grid-template-columns: repeat(var(--n), var(--square-size));
    grid-template-rows:    repeat(var(--n), var(--square-size));
  }
  .cell{
    width: var(--square-size);
    height: var(--square-size);
    position: relative;
    transform-style: preserve-3d;
  }

  .tile img {
  user-select: none;        /* empêche la sélection */
  pointer-events: none;     /* ignore les clics, laisse passer vers le parent */
  -webkit-user-drag: none;  /* désactive le drag natif dans WebKit (Chrome, Safari) */
}
  .tile{
    position:absolute;
    left:50%; top:50%;
    width: var(--square-size); height: var(--square-size);
    border-radius: 5px; /* déjà demandé précédemment */
    border:2px solid #0c4a6e;
    background: linear-gradient(#b9e6ff,#79c5ff);
    color:#05324a; font-weight:800;
    display:flex; align-items:center; justify-content:center;
    box-shadow: 0 8px 20px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.25);
    transform-origin: center center;
    transition: transform 480ms cubic-bezier(.3,.7,.2,1);
    will-change: transform;
    overflow: hidden;
  }
  .tile img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* ===== Panneau de contrôle ===== */
  #controlPanel{
    background:#f9f9f9;
    display:flex;
    align-items: stretch;
    justify-content:flex-start;
    gap:14px;
    padding:12px;
    flex-wrap: nowrap;
    overflow: auto;
  }

  /* Conteneur de la télécommande : scrollable + centré, jamais coupée */
  #remoteWrapper{
    position: relative;
    flex: 1 1 auto;
    min-width: 220px;
    padding: 12px;
    border-radius: 10px;
    background: #fff;
    border: 1px solid #ddd;
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: auto;                 /* ⇒ si n grand, on scrolle, pas de coupe */
  }
  #remote{
    position: relative;             /* référence pour centrage visuel */
    display:grid;
    justify-content:center;
    align-items: center;
    gap:8px;
    grid-template-columns: repeat(var(--n), var(--remote-btn));
    grid-template-rows:    repeat(var(--n), var(--remote-btn));
  }
  #remote button{
    width:var(--remote-btn); height:var(--remote-btn);
    border-radius:10px; border:2px solid #0b5a20;
    background: linear-gradient(#a7efb3,#73d88a);
    font-weight:800; color:#0b3816; cursor:pointer;
    box-shadow: 0 6px 12px rgba(0,0,0,.28), inset 0 0 0 1px rgba(255,255,255,.25);
    flex: 0 0 auto;
  }
  #remote button:disabled{ opacity:.6; cursor:not-allowed; }

  /* Donut = rotation globale, centré par-dessus la grille (taille = bouton) */
  #rotateDonut{
    position:absolute;
    left:50%; top:50%;
    transform: translate(-50%, -50%);
    width: var(--remote-btn);
    height: var(--remote-btn);
    border-radius: 50%;
    border: calc(var(--remote-btn) / 7.5) solid #666; /* épaisseur relative */
    background: transparent;
    display:flex; align-items:center; justify-content:center;
    pointer-events: auto;
    cursor: pointer;
    z-index: 5;                      /* au-dessus des boutons */
  }
  #rotateDonut.disabled{ pointer-events: none; opacity: .5; }
  #rotateDonut .donut-center{
    width: calc(var(--remote-btn) * 0.5);
    height: calc(var(--remote-btn) * 0.5);
    border-radius: 50%;
    background: #4CAF50;             /* vert = prêt */
    transition: background .2s linear;
  }

  .btn{
    padding:10px 14px; border-radius:10px; border:2px solid #0f172a;
    background:#e5e7eb; color:#0f172a; font-weight:800; cursor:pointer;
  }
  .btn:disabled{ opacity:.6; cursor:not-allowed; }

  .sliders{
    flex: 0 0 auto;
    display:flex; flex-direction:column; gap:12px; padding:6px;
    align-items:flex-start;
    min-width: 220px;
  }
  .sliders label{ display:flex; flex-direction:column; align-items:flex-start; font-size:12px; gap:6px; }
  .sliders input[type="range"]{ width:220px; }

  /* Petite zone utilitaires boutons à droite (reset / images) */
  #tools{
    flex: 0 0 auto;
    display:flex; flex-direction:column; gap:10px; align-items:flex-start; justify-content:flex-start;
    min-width: 220px;
  }
</style>
</head>
<body>

<!-- ===== Viewer 3D ===== -->
<div id="viewer">
  <div id="viewWrap">
    <div id="logicWrap">
      <div id="grid"></div>
    </div>
  </div>
</div>

<!-- ===== Panneau de contrôle (responsive) ===== -->
<div id="controlPanel">
  <div id="remoteWrapper">
    <div id="remote"></div>
    <!-- Donut (rotation globale) centré dans la télécommande -->
    <div id="rotateDonut" title="Rotation globale (appui court: +45°, appui long: -45°)">
      <div class="donut-center"></div>
    </div>
  </div>

  <div class="sliders">
    <label>n
      <input type="range" id="nSlider" min="2" max="8" value="2" step="2" />
    </label>
    <label>F (étages)
      <input type="range" id="fSlider" min="1" max="8" value="2"/>
    </label>
    <label>Gap (espacement XY)
      <input type="range" id="gapSlider" min="0" max="120" value="0"/>
    </label>
  </div>

  <div id="tools">
    <button id="resetViewBtn" class="btn">Reset Vue 3D</button>
    <button id="loadImagesBtn" class="btn">Charger images par défaut</button>
  </div>
</div>

<script>
/* =========================
   ÉTAT GLOBAL (inchangé)
   ========================= */
const state = {
  n: 2,
  F: 2,
  gap: 0,
  floorDepth: 30,
  logicalRotationRaw: 0,
  rotateStep: 45,
  isAnimating: false,
  tiles: [],
};

const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
const mod = (a,n)=>((a % n)+n)%n;

/* =========================
   TRANSITIONS HELPER
   ========================= */
function onTransitionEndOnce(el, prop, timeout=1200){
  return new Promise(resolve=>{
    let done=false;
    const t = setTimeout(()=>{ if(!done){done=true; cleanup(); resolve();}}, timeout);
    const handler = (e)=>{ if(done) return; if(e.propertyName===prop){ done=true; cleanup(); resolve(); } };
    function cleanup(){ clearTimeout(t); el.removeEventListener('transitionend', handler); }
    el.addEventListener('transitionend', handler);
  });
}

/* =========================
   SÉLECTIONS DOM
   ========================= */
const grid = document.getElementById('grid');
const remote = document.getElementById('remote');
const donut = document.getElementById('rotateDonut');
const donutCenter = donut.querySelector('.donut-center');

/* =========================
   CALCUL TAILLE DYNAMIQUE
   - moitié de la taille visible du viewer
   - on retire l'espace pris par les gaps
   - on divise par n
   ========================= */
function updateSquareSize(){
  const viewerRect = document.getElementById('viewer').getBoundingClientRect();
  const halfMin = Math.min(viewerRect.width, viewerRect.height) / 2;

  const n = state.n;
  const gap = state.gap;

  // largeur/hauteur totale d'une grille n x n :
  // total = n * size + (n - 1) * gap  => size = (target - (n-1)*gap)/n
  const target = Math.max(0, halfMin); // moitié d'écran pour l'ensemble
  const size = Math.floor((target - (n - 1) * gap) / n);

  const finalSize = Math.max(10, size); // garde une taille mini
  document.documentElement.style.setProperty('--square-size', `${finalSize}px`);
}

/* =========================
   CONSTRUCTION GRILLE
   ========================= */
function buildGrid(){
  document.documentElement.style.setProperty('--n', state.n);
  document.documentElement.style.setProperty('--gap', `${state.gap}px`);

  grid.innerHTML = '';
  state.tiles = [];
  for(let r=0;r<state.n;r++){
    for(let c=0;c<state.n;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.dataset.row = r;
      tile.dataset.col = c;

      // Drag & Drop images
      tile.addEventListener('dragover', e => e.preventDefault());
      tile.addEventListener('drop', e => {
        e.preventDefault();
        const file = e.dataTransfer.files[0];
        if(file && file.type.startsWith('image/')){
          const img = document.createElement('img');
          img.src = URL.createObjectURL(file);
          tile.innerHTML = '';
          tile.appendChild(img);
        }
      });

      cell.appendChild(tile);
      grid.appendChild(cell);

      state.tiles.push({row:r, col:c, floor:0, rotRaw:0, el:tile});
      applyTileTransform(state.tiles[state.tiles.length-1]);
    }
  }
}

/* =========================
   TÉLÉCOMMANDE
   ========================= */
function buildRemote(){
  remote.innerHTML = '';
  for(let vr=0; vr<state.n; vr++){
    for(let vc=0; vc<state.n; vc++){
      const btn = document.createElement('button');
      btn.dataset.visualRow = vr;
      btn.dataset.visualCol = vc;
      btn.dataset.targetRow = vr;
      btn.dataset.targetCol = vc;

      attachPressHandlers(
        btn,
        () => triggerTileSequence(parseInt(btn.dataset.targetRow,10), parseInt(btn.dataset.targetCol,10), false),
        () => triggerTileSequence(parseInt(btn.dataset.targetRow,10), parseInt(btn.dataset.targetCol,10), true)
      );

      remote.appendChild(btn);
    }
  }
  // s'assurer que le donut est centré par-dessus la grille après (re)build
  centerDonutOverRemote();
}

/* centre visuel du donut au milieu de la grille */
function centerDonutOverRemote(){
  // Donut déjà en absolute; on s'assure juste qu'il reste au-dessus
  donut.style.zIndex = '5';
}

/* =========================
   MAPPING télécommande -> tableaux
   (inchangé)
   ========================= */
function updateMapping(){
  const angle = mod(state.logicalRotationRaw, 360);
  if (angle % 90 !== 0) return;

  const n = state.n;
  document.querySelectorAll('#remote button').forEach(btn=>{
    const vr = parseInt(btn.dataset.visualRow,10);
    const vc = parseInt(btn.dataset.visualCol,10);

    let r0 = vr, c0 = vc;
    if(angle === 90){
      r0 = n - 1 - vc;
      c0 = vr;
    } else if(angle === 180){
      r0 = n - 1 - vr;
      c0 = n - 1 - vc;
    } else if(angle === 270){
      r0 = vc;
      c0 = n - 1 - vr;
    }
    btn.dataset.targetRow = r0;
    btn.dataset.targetCol = c0;
  });
}

/* =========================
   TRANSFORMS (centré)
   ========================= */
function applyTileTransform(t){
  const localTransform =
    `rotateZ(${t.rotRaw}deg) translateZ(${t.floor * state.floorDepth}px)`;
  t.el.style.transform =
    `translate(-50%, -50%) ${localTransform}`;
}

/* =========================
   GESTION appui court/long (inchangée)
   ========================= */
function attachPressHandlers(el, onShort, onLong, threshold=400){
  let timer=null, longFired=false, down=false;
  const clear = ()=>{ if(timer){ clearTimeout(timer); timer=null; } longFired=false; down=false; };

  el.addEventListener('pointerdown', ()=>{
    if(state.isAnimating) return;
    down=true; longFired=false;
    timer = setTimeout(()=>{
      if(!down) return;
      longFired=true;
      onLong();                       // long ⇒ déclenche tout de suite
    }, threshold);
  });

  el.addEventListener('pointerup', ()=>{
    if(!down) return;
    const wasLong = longFired;
    clear();
    if(state.isAnimating) return;
    if(!wasLong){ onShort(); }        // court ⇒ au relâchement
  });
  el.addEventListener('pointercancel', clear);
}

/* =========================
   ANIMS par tableau (inchangées)
   ========================= */
function getTile(r,c){ return state.tiles.find(t=>t.row===r && t.col===c); }

async function triggerTileSequence(r, c, reverse=false){
  if(state.isAnimating) return;
  state.isAnimating = true;
  setControlsEnabled(false);
  const t = getTile(r,c);
  const targetFloor = clamp(2, 0, state.F);
  try{
    await translateTile(t, targetFloor, 480);
    await rotateTile(t, reverse ? -90 : 90, 480);
    await translateTile(t, 0, 480);
  } finally {
    setControlsEnabled(true);
    state.isAnimating = false;
  }
}

function translateTile(t, floor, duration=480){
  return new Promise(resolve=>{
    t.floor = clamp(floor, 0, state.F);
    t.el.style.transition = `transform ${duration}ms cubic-bezier(.3,.7,.2,1)`;
    applyTileTransform(t);
    onTransitionEndOnce(t.el, 'transform', duration+200).then(resolve);
  });
}

function rotateTile(t, deltaDeg, duration=480){
  return new Promise(resolve=>{
    const snapped = Math.round(deltaDeg/90)*90;
    t.rotRaw += snapped;
    t.el.style.transition = `transform ${duration}ms cubic-bezier(.3,.7,.2,1)`;
    applyTileTransform(t);
    onTransitionEndOnce(t.el, 'transform', duration+200).then(resolve);
  });
}

/* =========================
   ROTATION GLOBALE via DONUT
   ========================= */
attachPressHandlers(
  donut,
  () => rotateGlobal(+state.rotateStep, 900),
  () => rotateGlobal(-state.rotateStep, 900)
);

const logicWrap = document.getElementById('logicWrap');

function rotateGlobal(stepDeg, duration=900){
  if(state.isAnimating) return;
  state.isAnimating = true;
  setControlsEnabled(false);                 // centre donut → rouge
  state.logicalRotationRaw += stepDeg;
  logicWrap.style.transition = `transform ${duration}ms cubic-bezier(.3,.7,.2,1)`;
  logicWrap.style.transform  = `rotateZ(${state.logicalRotationRaw}deg)`;
  onTransitionEndOnce(logicWrap, 'transform', duration+200).then(()=>{
    logicWrap.style.transition = '';
    if (mod(state.logicalRotationRaw, 90) === 0) updateMapping();
    setControlsEnabled(true);                // centre donut → vert
    state.isAnimating = false;
  });
}

/* =========================
   ROTATION DE VUE (drag)
   ========================= */
(function setupViewDrag(){
  const viewer = document.getElementById('viewer');
  const viewWrap = document.getElementById('viewWrap');
  let dragging=false, lastX=0, lastY=0, rx=0, ry=0;
  const apply = ()=>{ viewWrap.style.transform = `rotateX(${rx}deg) rotateY(${ry}deg)`; };
  apply();
  viewer.addEventListener('pointerdown', e=>{
    dragging=true; lastX=e.clientX; lastY=e.clientY; viewer.setPointerCapture(e.pointerId);
  });
  viewer.addEventListener('pointerup', e=>{
    dragging=false; viewer.releasePointerCapture(e.pointerId);
  });
  viewer.addEventListener('pointermove', e=>{
    if(!dragging) return;
    ry += (e.clientX - lastX) * 0.35;
    rx -= (e.clientY - lastY) * 0.35;
    rx = clamp(rx, -80, 80);
    apply();
    lastX=e.clientX; lastY=e.clientY;
  });
  document.getElementById('resetViewBtn').addEventListener('click', ()=>{
    rx = 0; ry = 0; apply();
  });
})();

/* =========================
   SLIDERS
   ========================= */
document.getElementById('nSlider').addEventListener('input', e=>{
  state.n = parseInt(e.target.value,10);
  document.documentElement.style.setProperty('--n', state.n);
  buildGrid();
  buildRemote();
  updateMapping();
  updateSquareSize();                 // ⇒ recalcul taille avec n + gap
});
document.getElementById('fSlider').addEventListener('input', e=>{
  state.F = parseInt(e.target.value,10);
});
document.getElementById('gapSlider').addEventListener('input', e=>{
  state.gap = parseInt(e.target.value,10);
  document.documentElement.style.setProperty('--gap', `${state.gap}px`);
  updateSquareSize();                 // ⇒ tient compte du gap
});

/* =========================
   ENABLE/DISABLE CONTROLS
   ========================= */
function setControlsEnabled(enabled){
  document.querySelectorAll('#remote button').forEach(b=> b.disabled = !enabled);
  if(!enabled){
    donut.classList.add('disabled');
    donutCenter.style.background = '#F44336'; // rouge en anim
  } else {
    donut.classList.remove('disabled');
    donutCenter.style.background = '#4CAF50'; // vert prêt
  }
}

/* =========================
   CHARGER images par défaut (n=2)
   ========================= */
document.getElementById('loadImagesBtn').addEventListener('click', ()=>{
  if(state.n !== 2) return alert("Fonction dispo uniquement si n=2");
  const mapping = {
    "0,0": "tl.png",
    "0,1": "tr.png",
    "1,0": "bl.png",
    "1,1": "br.png"
  };
  state.tiles.forEach(t=>{
    const key = `${t.row},${t.col}`;
    if(mapping[key]){
      const img = document.createElement('img');
      img.src = mapping[key];
      t.el.innerHTML = '';
      t.el.appendChild(img);
    }
  });
});

/* =========================
   INIT
   ========================= */
(function init(){
  document.documentElement.style.setProperty('--n', state.n);
  document.documentElement.style.setProperty('--gap', `${state.gap}px`);
  buildGrid();
  buildRemote();
  updateMapping();
  updateSquareSize();
  window.addEventListener('resize', updateSquareSize);
})();
</script>
</body>
</html>
